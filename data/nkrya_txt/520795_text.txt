 А. Ю. Савинков.
 Имитационное статистическое моделирование на ЭВМ является одним из основных инструментом анализа и синтеза при разработке систем цифровой обработки сигнала.
 Для сокращения сроков разработки и отладки программ моделирования и снижения риска ошибок в программах предлагается ввести в библиотеку классов имитационного моделирования наряду с классами, представляющими объекты предметной области исследования, ещё два класса - объект « часы» и объект « отладочная точка».
 Описанная концепция использовалась в практической работе Воронежского НИИ связи и показала высокую эффективность для имитационного моделирования цифровой обработки сигнала в различных системах связи.
 В настоящее время имитационное статистическое моделирование на ЭВМ является основным инструментом не только для анализа, но также и для параметрического и для структурного синтеза при разработке систем цифровой обработки сигнала ( средства радиосвязи, навигации, локации и т. п.). Это связано с наблюдаемым в последнее время резким усложнением подобных систем.
 В результате аналитические методы анализа и синтеза потеряли свою эффективность - сложность аналитического описания современных систем цифровой обработки сигналов, особенно если требуется учитывать влияние среды распространения сигнала или нелинейные эффекты ограничения и квантования, становится слишком высокой, а попытки ввести хотя бы небольшие упрощения в аналитическую модель негативно отражаются на её адекватности.
 Таким образом, имитационное моделирование в большинстве случаев оказывается более адекватным и менее сложным.
 Жёсткие временные рамки разработки новых систем цифровой обработки сигнала и жёсткая конкуренция между разработчиками таких систем определяют требования к используемым имитационным моделям.
 Прежде всего, имитационная модель должна удовлетворять двум основным требованиям:
 адекватность модели исследуемой системе;
 максимальное быстродействие при минимуме затрат на разработку и верификацию модели.
 Выполнить на практике первое требование оказывается не очень сложно.
 Действительно, при использовании цифровой обработки сигнала в компьютерной модели можно прямо использовать реальные алгоритмы, а статистические модели для учёта влияния среды ( шум, замирания сигнала, многолучевое распространение) хорошо отработаны и многократно верифицированы [ 1, 2 ].
 Больше проблем вызывает выполнение второго требования.
 Желание сократить затраты на разработку и верификацию программы моделирования вынуждает разработчика обратиться к универсальным пакетам имитационного моделирования, таким как MATLAB Simulink [ 3 ], который широко распространён в научной среде, или ADS, который больше известен среди инженеров.
 Применение подобных пакетов моделирования позволяет существенно сократить затраты на разработку модели за счёт использования технологии визуального программирования.
 Библиотечные компоненты, входящие в состав таких пакетов моделирования и реализующие основные блоки цифровой обработки сигнала, многократно верифицированы разработчиком пакета моделирования, что снижает риск ошибок в полученной модели.
 Однако применение универсальных пакетов моделирования имеет и негативную сторону - ограниченное быстродействие полученной программной модели.
 Снижение быстродействия обусловлено несколькими причинами, среди которых можно указать следующие:
 универсальный интерфейс библиотечных компонентов обычно оказывается слишком сложным и громоздким, приводящим к заметным накладным расходам уже на этапе передачи данных между модулями;
 библиотечные компоненты разработаны в целях максимальной гибкости и широты использования, поэтому часто являются перегружёнными всевозможными проверками режимов и альтернативными ветвями вычислений;
 в большинстве случаев полученная программа выполняется в режиме интерпретатора.
 Безусловно, следует отметить, что большинство современных пакетов имитационного моделирования позволяет пользователю включать в модель собственные компоненты, реализованные на любом языке программирования и оптимизированные под конкретные потребности пользователя.
 Эти компоненты вызываются программой моделирования как библиотечные функции, и их применение способно существенно поднять быстродействие модели.
 Но разработка таких компонентов является сложной задачей, требующей времени и тщательной верификации промежуточных результатов на каждом этапе работы.
 При массированном применении таких компонентов разработка модели с использованием универсального пакета имитационного моделирования может оказаться даже сложнее, чем полная разработка модели на универсальном компилирующем языке программирования типа Си, в то время как максимально возможное для данного типа ЭВМ быстродействие так и не будет достигнуто.
 Поэтому при практической разработке сложных имитационных моделей, если имеются ограничения по сроку разработки и времени моделирования, во многих случаях оправдано применение универсальных языков программирования в сочетании с технологией объектно-ориентированного программирования [ 4, 5 ].
 Для сокращения срока разработки, упрощения верификации и снижения риска ошибок в программах моделирования очень удобным оказывается применение специально разработанных библиотек классов, прямо представляющих объекты предметной области исследования в виде объектов языка программирования [ 6 ].
 Применительно к моделированию систем цифровой обработки сигналов подобная библиотека может включать такие объекты, как фильтры, дискретные преобразователи ( FFT, FHT), генераторы стандартных сигналов ( шумы с различными характеристиками, M - последовательности и т. п.), имитаторы каналов распространения.
 В настоящее время существует целый ряд таких библиотек [ 7 ].
 Таким образом, использование объектно-ориентированного программирования и специализированных библиотек классов позволяет достичь хорошего компромисса между сложностью разработки и верификации программной модели и результирующей скоростью моделирования.
 Однако, чтобы такой подход хотя бы приблизился по степени удобства использования и универсальности применения к традиционным пакетам имитационного моделирования, необходимо, помимо библиотек классов предметной области, предоставить пользователю и средства обеспечения моделирования, в первую очередь - средство синхронизации компонентов модели, средства отладки и верификации программной модели.
 В данной статье предлагается подход для обеспечения синхронизации компонентов модели и организации псевдопараллельных вычислений на основе объекта « часы», используемого или наследуемого другими объектами библиотеки классов, требующих взаимной синхронизации в ходе моделирования.
 Кроме того, предлагается подход к отладке и верификации модели на основе объекта « отладочная точка», используемого при разработке программы моделирования вместо обычных переменных.
 Объект « часы»
 При моделировании систем цифровой обработки сигналов необходимо установить и поддерживать заданные временные соотношения между компонентами модели, причём иногда необходимо выполнять динамическую пересинхронизацию.
 Существует множество альтернативных способов компоновки модели из базовых объектов: технология обратного вызова, списки вызова и др.
 Известны решения, позволяющие формализовать компоновку модели, вплоть до использования средств визуального программирования.
 Однако в практических случаях наиболее удобным часто оказывается простейший подход, основанный на ручной компоновке модели за счёт последовательного расположения объектов программы в теле главного цикла моделирования.
 Один проход главного цикла соответствует минимальному временному интервалу дискретного времени модели.
 Все остальные временные интервалы, используемые в модели, должны быть кратными этому минимальному интервалу.
 Применительно к моделированию систем цифровой обработки сигнала в основном приходится сталкиваться с периодическими временными структурами - кадрами, информационными символами, элементами дискретных последовательностей, информационными блоками на разных уровнях обработки сигнала.
 В практике программирования для отслеживания границ периодических временных интервалов наиболее удобно использовать остаток от деления глобального счётчика дискретного времени на временной интервал.
 При этом предлагается с каждым синхронизируемым объектом связать собственный объект « часы», имеющий собственный счётчик дискретного времени.
 В объекте « часы» может быть легко реализована функция типа
 bool isTimeCoincide ( unsigned time Period, unsigned time)
 Функция возвращает true, если остаток от деления счётчика дискретного времени на timePeriod равен time.
 Например, для отслеживания начала временных интервалов по 10 единиц дискретного времени можно использовать в программе следующую инструкцию:
 if ( isTimeCoincide ( 10, 0))<...>
 При таком подходе программа моделирования строится на основе событийной модели, где событиями являются начала или окончания временных интервалов.
 При наступлении события объект предпринимает некоторые заранее определённые действия, например, в начале временного интервала передатчик может подготовить данные для передачи, в конце временного интервала приёмник может вынести решение о принятых данных и т. п.
 Для учёта задержки сигнала в отдельных компонентах модели, таких как фильтры или имитаторы каналов распространения, начала отсчётов часов каждого объекта могут соответствующим образом смещаться.
 Описанная концепция позволяет легко установить статическую синхронизацию модели, однако в системах цифровой обработки сигнала часто требуется выполнять динамическую пересинхронизацию, заключающуюся во взаимном смещении положений временных интервалов объектов в ходе моделирования, например, если из-за изменения задержки распространения сигнала требуется скорректировать время начала кадра в приёмнике.
 На первый взгляд представляется, что такую коррекцию можно сделать простым изменением значения счётчика дискретного времени в объекте « часы», но при использовании событийной модели это может привести к ошибкам, связанным с пропуском или повторным возникновением событий.
 В самом деле, если просто перевести часы вперёд, то некоторые события будут пропущены, а если назад - то уже обработанные события снова возникнут.
 В результате объекты имитационной модели перейдут в некорректные состояния.
 Поэтому единственным корректным способом динамической пересинхронизации является приостановка часов объекта на некоторое время.
 Пока часы объекта стоят, никакие события для него не возникают, в то время как дискретное время других объектов продолжает идти вперёд.
 Таким образом, за счёт остановки часов дискретное время объекта можно сместить назад относительно времени других объектов.
 Для того чтобы сместить дискретное время выделенного объекта вперёд, нужно приостановить на заданное время часы всех других объектов имитационной модели.
 Для того чтобы иметь возможность выполнять приостановку часов на заданное время, в объект « часы» необходимо ввести вспомогательный счётчик - счётчик времени ожидания.
 Если значение этого счётчика равно нулю, то при ходе часов инкрементируется основной счётчик, если же значение вспомогательного счётчика времени ожидания не равно нулю, то он декрементируется при ходе часов, а основной счётчик остаётся без изменений.
 Так как часы в состоянии ожидания не вырабатывают никаких событий, то можно произвольно управлять временем ожидания, увеличивая или уменьшая его даже у приостановленных уже часов.
 Для автоматизации групповых операций с часами ( например, приостановка всех часов при переводе одних часов вперёд) часы всех объектов программной модели связываются в единый список.
 Конструктор объекта « часы» автоматически включает новый экземпляр часов в список при его создании.
 Для поддержки динамической синхронизации в объект « часы» должна быть добавлена соответствующая функция, определённая, например, следующим образом:
 void AdJustClock ( int ticks)
 При отрицательном значении параметра ticks к счётчику ожидания часов добавляется величина abs ( ticks).
 При положительном значении ticks его значение добавляется к счётчикам ожидания в часах всех остальных объектов программной модели.
 Так как в модели может одновременно использоваться несколько объектов « часы», к любым из которых может быть применена произвольная коррекция, а перевод вперёд даже единственных часов требует вмешательства в работу всех остальных часов модели, то немедленная коррекция счётчиков ожидания при вызове функции AdjustClock неоправдана.
 Более эффективным представляется просто запомнить требуемое значение коррекции, переданное в функцию AdjustClock.
 При этом, если AdjustClock будет несколько раз вызвана от одних и тех же часов, то все введённые значения коррекции суммируются.
 После каждого прохода главного цикла программы моделирования выполняется процедура коррекции всех часов одновременно.
 Описанная концепция реализована в классе объект « часы» на языке Си ++, апробирована в процессе моделирования различных систем цифровой обработки сигнала и показала свою высокую эффективность и удобство использования.
 Объект « отладочная точка»
 В процессе отладки и верификации имитационной программной модели довольно часто возникает ситуация, когда для анализа требуется получить выборку сигнала из определённой точки программной модели или, наоборот, ввести в заданную точку модели некоторую внешнюю реализацию сигнала.
 При использовании для разработки программной модели универсального языка программирования, чтобы решить такие задачи, обычно приходится модифицировать исходный код модели.
 Однако, если исходный код программы достаточно объёмный, то даже простая перекомпиляция программы после изменения исходного кода может занять много времени.
 Кроме того, постоянная модификация исходного кода повышает вероятность возникновения ошибок в программном коде модели.
 Поэтому целесообразно в библиотеку классов объектов имитационного моделирования ввести универсальный объект « отладочная точка», который может использоваться в коде программы вместо обычных переменных.
 Класс « отладочная точка» должен строиться как некоторая оболочка над переменной программы.
 Он должен обеспечивать прозрачность операций присваивания в обе стороны, т. е. запись нового значения в контролируемую переменную и считывание её значения должны выполняться одинаково, независимо от того, используется ли переменная в чистом виде или через оболочку « отладочной точки».
 В то же время оболочка « отладочная точка» должна предоставить полный контроль над данными, проходящими через переменную, включая возможность трассировки или даже подмены данных.
 Техника программирования, позволяющая создавать подобные прозрачные классы - оболочки, хорошо изложена в [ 8 ] на примере объекта « умный указатель»( smart pointer).
 Реализовать объект « отладочная точка» возможно с использованием технологии шаблонов и объектно-ориентированного программирования.
 Для этого необходимо определить шаблонный класс - обёртку для переменной некоторого типа T и определить в этом классе оператор преобразования типа к T & и оператор присваивания:
 Переопределенные операторы обеспечивают прозрачность отладочной точки по отношению к операциям присваивания - оператор преобразования типа неявно вызывается компилятором при чтении значения переменной, а оператор присваивания - при модификации.
 Оператор преобразования типа при этом реализуется тривиально, он предназначен только для обеспечения прозрачности чтения значения переменной и не выполняет больше никаких действий.
 Оператор присваивания, помимо обеспечения прозрачности записи ( модификации) переменной, реализует контроль над всеми данными, проходящими через отладочную точку.
 Действительно, так как модификация значения контролируемой переменной возможна только через переопределенный оператор присваивания, то не составляет особого труда реализовать трассировку данных, т. е. запись в файл всех значений, присваиваемых переменной в ходе работы программы, или подмену значения переменной в ходе присваивания, например, на значение, считанное из файла.
 Экземпляры класса « отладочная точка» можно включать в тексты программ вместо простых переменных типа Т и затем использовать в выражениях как обычные переменные, например:
 DebugPoint <int>x,x=5;
 int y = 7, z; z = x + y;
 С точки зрения дальнейшего использования переменной в программе нет разницы, как она объявлена: int x или DebugPoint <int>x.
 Для того чтобы работать с отладочными точками было более удобно, был реализован управляющий интерфейс отладочных точек.
 Внешний вид главного окна управляющего интерфейса отладочных точек показан на рисунке.
 При создании все отладочные точки автоматически вносятся их конструкторами в бинарное дерево, сбалансированное по именам отладочных точек, которые должны быть указаны программистом в тексте программы при объявлении отладочной точки.
 Главное окно управляющего интерфейса отладочных точек отображает список всех существующих на данный момент отладочных точек и текущий режим каждой из них.
 Выбрав в списке главного окна управляющего интерфейса требуемую отладочную точку, пользователь может изменить её параметры.
 Данные из отладочной точки, сохранённые в указанном файле, затем могут быть проанализированы отдельно.
 Отладочные точки позволяют существенно сократить время, затрачиваемое на отладку и верификацию программ имитационного моделирования, а также в любой момент получить из программы контрольную выборку данных или проверить работу программного модуля с помощью внешних данных из файла.
 При этом наличие в программе даже большого числа неактивных отладочных точек практически не сказывается на быстродействии программы.
 При необходимости функциональность класса « отладочная точка» может быть легко расширена, например, отладочная точка могла бы отслеживать средние параметры сигнала, проходящего через неё, среднее значение, дисперсию или др.
 Безусловно, предложенный класс « отладочных точек» имеет ограниченную применимость и в некоторых случаях не может прямо использоваться вместо простых переменных.
 Например, невозможно получить доступ к контролируемым переменным через указатели.
 Действительно,« отладочная точка» не является простой переменной, и попытка трактовать содержимое памяти в месте расположения отладочной точки как число в некотором формате некорректна.
 Однако наличие такого ограничения не приводит к каким-либо серьёзным неудобствам на практике, в то время как получаемые преимущества в скорости и удобстве работы весьма заметны.
 Пример использования объекта « часы» в моделировании
 В качестве примера, иллюстрирующего использование объекта « часы» в программе моделирования, рассмотрим имитационную модель простейшей системы связи на основе технологии прямого расширения спектра с модуляцией BPSK [ 9 ].
 Сигнал передатчика в такой системе связи представляет собой фрагменты псевдослучайной последовательности, известной приёмнику.
 Начальная фаза каждого из фрагментов определяется передаваемыми двоичными данными и равна 0 или π.
 Математическая модель передаваемого сигнала может быть определена следующим образом:
 Следовательно, при дискретизации сигнала ( 1) неизбежны неустранимые искажения сигнала, но их уровень существенно зависит от значения k и может стать пренебрежимо малым при достаточно большом k.
 Параметры k и N являются важнейшими характеристиками системы связи, которые должны быть оптимизированы в ходе моделирования.
 Если параметр k будет выбран слитком большим, то это приведёт только к усложнению и росту стоимости аппаратуры связи, при этом качество связи не улучшится.
 Напротив, при слишком малом значении k искажения сигнала могут стать неприемлемыми.
 Значение параметра N определяет компромисс между помехоустойчивостью приёма, скоростью передачи и полосой частот системы связи.
 Использование объекта « часы» позволяет легко изменять эти параметры без внесения изменений в код программы.
 Далее, в качестве примера приводятся классы приёмника и передатчика простейшей системы связи с прямым расширением спектра.
 Простейший класс на Си ++, реализующий передатчик с прямым расширением спектра сигнала, может быть определён следующим образом:
 Объекты « отладочная точка», представляющие вход данных и выход отсчётов сигнала, позволяют легко контролировать работу модели.
 Аналогичным образом можно определить класс приёмник, только в отличие от класса передатчика часы приёмника должны регистрировать не начало, а конец временных интервалов.
 Далее приводится участок кода основной программы, реализующий модель системы связи с прямым расширением спектра сигнала:
 Под руководством и при непосредственном участии автора по описанной методике были разработаны имитационные модели передатчиков и приёмников систем связи по международным стандартам IS - 95, 3 GPP 2, 3 GPP, IEEE 802. 11 и ряду других.
 Разработанные имитационные модели использовались Воронежским НИИ связи ( ВНИИС) на этапе разработки алгоритмов цифровых модемов.
 По оценкам специалистов ВНИИС использование данных имитационных моделей сократило время разработки более чем на порядок.
 При этом последующие испытания аппаратуры показали хорошее соответствие модельных оценок и реальных характеристик.
 Рис. Внешний вид главного окна управляющего интерфейса отладочных точек
